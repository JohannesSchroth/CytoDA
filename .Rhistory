insertUI(
selector = "#placeholder",
where = "beforeBegin",
ui = row_ui(input$name)
)
handler_list <- isolate(handler())
new_handler <- callModule(row_server, input$name)
handler_list <- c(handler_list, new_handler)
names(handler_list)[length(handler_list)] <- input$name
handler(handler_list)
})
output$out <- renderPrint({
lapply(handler(), function(handle) {
handle()
})
})
}
shinyApp(ui, server)
row_ui <- function(id) {
ns <- NS(id)
fluidRow(
column(3, orderInput(ns('dest'), ns(input$name), items = NULL, placeholder = 'Drag items here...')),
column(9, uiOutput(ns("ui_placeholder"))
)
)
}
row_server <- function(input, output, session) {
return_value <- reactive({input$inner_element})
ns <- session$ns
output$ui_placeholder <- renderUI({
type <- req(input$dest)
if(type == "text") {
textInput(ns("inner_element"), "Text:")
} else if (type == "numeric") {
numericInput(ns("inner_element"), "Value:", 0)
}
})
## if we later want to do some more sophisticated logic
## we can add reactives to this list
list(return_value = return_value)
}
ui <- fluidPage(
div(id="placeholder"),
textInput('name', 'Name'),
actionButton("addLine", "Add Line"),
verbatimTextOutput("out")
)
server <- function(input, output, session) {
handler <- reactiveVal(list())
observeEvent(input$addLine, {
insertUI(
selector = "#placeholder",
where = "beforeBegin",
ui = row_ui(input$name)
)
handler_list <- isolate(handler())
new_handler <- callModule(row_server, input$name)
handler_list <- c(handler_list, new_handler)
names(handler_list)[length(handler_list)] <- input$name
handler(handler_list)
})
output$out <- renderPrint({
lapply(handler(), function(handle) {
handle()
})
})
}
shinyApp(ui, server)
row_ui <- function(id) {
ns <- NS(id)
fluidRow(
column(3, orderInput(ns('dest'), ns(''), items = NULL, placeholder = 'Drag items here...')),
column(9, uiOutput(ns("ui_placeholder"))
)
)
}
row_server <- function(input, output, session) {
return_value <- reactive({input$inner_element})
ns <- session$ns
output$ui_placeholder <- renderUI({
type <- req(input$dest)
if(type == "text") {
textInput(ns("inner_element"), "Text:")
} else if (type == "numeric") {
numericInput(ns("inner_element"), "Value:", 0)
}
})
## if we later want to do some more sophisticated logic
## we can add reactives to this list
list(return_value = return_value)
}
ui <- fluidPage(
div(id="placeholder"),
textInput('name', 'Name'),
actionButton("addLine", "Add Line"),
verbatimTextOutput("out")
)
server <- function(input, output, session) {
handler <- reactiveVal(list())
observeEvent(input$addLine, {
insertUI(
selector = "#placeholder",
where = "beforeBegin",
ui = row_ui(input$name)
)
handler_list <- isolate(handler())
new_handler <- callModule(row_server, input$name)
handler_list <- c(handler_list, new_handler)
names(handler_list)[length(handler_list)] <- input$name
handler(handler_list)
})
output$out <- renderPrint({
lapply(handler(), function(handle) {
handle()
})
})
}
shinyApp(ui, server)
row_ui <- function(id) {
ns <- NS(id)
fluidRow(
column(3, orderInput(ns('dest'), ns(''), items = NULL, placeholder = 'Drag items here...')),
column(9, uiOutput(ns("ui_placeholder"))
)
)
}
row_server <- function(input, output, session) {
return_value <- reactive({input$inner_element})
ns <- session$ns
output$ui_placeholder <- renderUI({
type <- req(input$dest)
if(type == "text") {
textInput(ns("inner_element"), "Text:")
} else if (type == "numeric") {
numericInput(ns("inner_element"), "Value:", 0)
}
})
## if we later want to do some more sophisticated logic
## we can add reactives to this list
list(return_value = return_value)
}
ui <- fluidPage(
div(id="placeholder"),
orderInput('source', 'Source', items = c('1', '2', '3', '4'), as_source = TRUE, connect = input$ns('dest')),
textInput('name', 'Name'),
actionButton("addLine", "Add Line"),
verbatimTextOutput("out")
)
server <- function(input, output, session) {
handler <- reactiveVal(list())
observeEvent(input$addLine, {
insertUI(
selector = "#placeholder",
where = "beforeBegin",
ui = row_ui(input$name)
)
handler_list <- isolate(handler())
new_handler <- callModule(row_server, input$name)
handler_list <- c(handler_list, new_handler)
names(handler_list)[length(handler_list)] <- input$name
handler(handler_list)
})
output$out <- renderPrint({
lapply(handler(), function(handle) {
handle()
})
})
}
shinyApp(ui, server)
row_ui <- function(id) {
ns <- NS(id)
fluidRow(
column(3, orderInput(ns('dest'), ns(''), items = NULL, placeholder = 'Drag items here...')),
column(9, uiOutput(ns("ui_placeholder"))
)
)
}
row_server <- function(input, output, session) {
return_value <- reactive({input$inner_element})
ns <- session$ns
output$ui_placeholder <- renderUI({
type <- req(input$dest)
if(type == "text") {
textInput(ns("inner_element"), "Text:")
} else if (type == "numeric") {
numericInput(ns("inner_element"), "Value:", 0)
}
})
## if we later want to do some more sophisticated logic
## we can add reactives to this list
list(return_value = return_value)
}
ui <- fluidPage(
div(id="placeholder"),
orderInput('source', 'Source', items = c('1', '2', '3', '4'), as_source = TRUE, connect = 'dest'),
textInput('name', 'Name'),
actionButton("addLine", "Add Line"),
verbatimTextOutput("out")
)
server <- function(input, output, session) {
handler <- reactiveVal(list())
observeEvent(input$addLine, {
insertUI(
selector = "#placeholder",
where = "beforeBegin",
ui = row_ui(input$name)
)
handler_list <- isolate(handler())
new_handler <- callModule(row_server, input$name)
handler_list <- c(handler_list, new_handler)
names(handler_list)[length(handler_list)] <- input$name
handler(handler_list)
})
output$out <- renderPrint({
lapply(handler(), function(handle) {
handle()
})
})
}
shinyApp(ui, server)
remotes::install_github("rstudio/sortable")
library(sortable)
row_ui <- function(id) {
ns <- NS(id)
fluidRow(
column(3, orderInput(ns('dest'), ns(''), items = NULL, placeholder = 'Drag items here...')),
column(9, uiOutput(ns("ui_placeholder"))
)
)
}
row_server <- function(input, output, session) {
return_value <- reactive({input$inner_element})
ns <- session$ns
output$ui_placeholder <- renderUI({
type <- req(input$dest)
if(type == "text") {
textInput(ns("inner_element"), "Text:")
} else if (type == "numeric") {
numericInput(ns("inner_element"), "Value:", 0)
}
})
## if we later want to do some more sophisticated logic
## we can add reactives to this list
list(return_value = return_value)
}
ui <- fluidPage(
div(id="placeholder"),
bucket_list('Merge Clusters', group_name = "bucket_list_group", orientation = "horizontal", add_rank_list(
text = "Drag from here",
labels = list('1','2','3','4'),
input_id = "rank_list_1"
),
add_rank_list(
text = "to here",
labels = NULL,
input_id = "rank_list_2"
)
)),
textInput('name', 'Name'),
actionButton("addLine", "Add Line"),
verbatimTextOutput("out")
div(id="placeholder"),
bucket_list('Merge Clusters', group_name = "bucket_list_group", orientation = "horizontal", add_rank_list(
text = "Drag from here",
labels = list('1','2','3','4'),
input_id = "rank_list_1"
),
add_rank_list(
text = "to here",
labels = NULL,
input_id = "rank_list_2"
)
)),
textInput('name', 'Name'),
actionButton("addLine", "Add Line"),
verbatimTextOutput("out")
row_ui <- function(id) {
ns <- NS(id)
fluidRow(
column(3, orderInput(ns('dest'), ns(''), items = NULL, placeholder = 'Drag items here...')),
column(9, uiOutput(ns("ui_placeholder"))
)
)
}
row_server <- function(input, output, session) {
return_value <- reactive({input$inner_element})
ns <- session$ns
output$ui_placeholder <- renderUI({
type <- req(input$dest)
if(type == "text") {
textInput(ns("inner_element"), "Text:")
} else if (type == "numeric") {
numericInput(ns("inner_element"), "Value:", 0)
}
})
## if we later want to do some more sophisticated logic
## we can add reactives to this list
list(return_value = return_value)
}
ui <- fluidPage(
div(id="placeholder"),
bucket_list('Merge Clusters', group_name = "bucket_list_group", orientation = "horizontal", add_rank_list(
text = "Drag from here",
labels = list('1','2','3','4'),
input_id = "rank_list_1"
),
add_rank_list(
text = "to here",
labels = NULL,
input_id = "rank_list_2"
)
),
textInput('name', 'Name'),
actionButton("addLine", "Add Line"),
verbatimTextOutput("out")
)
server <- function(input, output, session) {
handler <- reactiveVal(list())
observeEvent(input$addLine, {
insertUI(
selector = "#placeholder",
where = "beforeBegin",
ui = row_ui(input$name)
)
handler_list <- isolate(handler())
new_handler <- callModule(row_server, input$name)
handler_list <- c(handler_list, new_handler)
names(handler_list)[length(handler_list)] <- input$name
handler(handler_list)
})
output$out <- renderPrint({
lapply(handler(), function(handle) {
handle()
})
})
}
shinyApp(ui, server)
row_ui <- function(id) {
ns <- NS(id)
add_rank_list(
text = "to here",
labels = NULL,
input_id = ns("rank_list_2")
)
}
row_server <- function(input, output, session) {
return_value <- reactive({input$inner_element})
ns <- session$ns
output$ui_placeholder <- renderUI({
type <- req(input$dest)
if(type == "text") {
textInput(ns("inner_element"), "Text:")
} else if (type == "numeric") {
numericInput(ns("inner_element"), "Value:", 0)
}
})
## if we later want to do some more sophisticated logic
## we can add reactives to this list
list(return_value = return_value)
}
ui <- fluidPage(
div(id="placeholder"),
bucket_list('Merge Clusters', group_name = "bucket_list_group", orientation = "horizontal", add_rank_list(
text = "Drag from here",
labels = list('1','2','3','4'),
input_id = "rank_list_1"
)
),
textInput('name', 'Name'),
actionButton("addLine", "Add Line"),
verbatimTextOutput("out")
)
server <- function(input, output, session) {
handler <- reactiveVal(list())
observeEvent(input$addLine, {
insertUI(
selector = "#placeholder",
where = "beforeBegin",
ui = row_ui(input$name)
)
handler_list <- isolate(handler())
new_handler <- callModule(row_server, input$name)
handler_list <- c(handler_list, new_handler)
names(handler_list)[length(handler_list)] <- input$name
handler(handler_list)
})
output$out <- renderPrint({
lapply(handler(), function(handle) {
handle()
})
})
}
shinyApp(ui, server)
df <- read.csv(file.choose())
head(df)
#' Create new variable
#'
library(dplyr)
str(df)
df %>% mutate(psytools_valid_flag = case_when(
ts_2 = 1 | ts_4 = 3 | ts_5 = 4 | ts_5 = 5 ~ 0 ,
)
)
df %>% mutate(psytools_valid_flag = case_when(
ts_2 = 1 | ts_4 = 3 | ts_5 = 4 | ts_5 = 5 ~ 0
)
)
df %>% mutate(psytools_valid_flag = case_when(ts_2 = 1 | ts_4 = 3 | ts_5 = 4 | ts_5 = 5 ~ 0))
df %>% mutate(psytools_valid_flag = case_when(ts_2 == 1 | ts_4 == 3 | ts_5 == 4 | ts_5 == 5 ~ 0))
head(df)
df %>% mutate(psytools_valid_flag = case_when(ts_2 == 1 | ts_4 == 3 ~ 0))
df %>% mutate(psytools_valid_flag = ifelse(ts_2 == 1 | ts_4 == 3 , 0))
df %>% mutate(psytools_valid_flag = ifelse(test = ts_2 == 1 | ts_4 == 3 , yes = 0, no = 1))
setwd('~/Desktop')
# Check it worked fine
df
# Create new variable based on conditions
df <- df %>%
mutate(psytools_valid_flag = ifelse(test = ts_2 == 1 | ts_4 == 3 , yes = 0, no = 1))
# Check it worked fine
df
# Set working direcotry
setwd('~/Desktop')
umap <- umap(df[,8:29])
umap <- umap::umap(df[,8:29])
umap$layout
df_umap <- umap$layout
plot(df_umap)
# Look at data
head(df)
head(df[,8:29])
ggplot(df_umap, aes(V1, V2)) +
geom_point()
library(ggplot2)
ggplot(df_umap, aes(V1, V2)) +
geom_point()
df_umap <- as.data.frame(umap$layout)
ggplot(df_umap, aes(V1, V2)) +
geom_point()
ggplot(df_umap, aes(V1, V2, colour = df$TFEQ_1)) +
geom_point()
ggplot(df_umap, aes(V1, V2, colour = df$ts_1)) +
geom_point()
custom <- umap::umap.defaults
tsne <- Rtsne::Rtsne(df[,8:29])
tsne <- Rtsne::Rtsne(df[,8:29], check_duplicates = FALSE)
df_tsne <- tsne$Y
head(df_tsne)
df_tsne <- as.data.frame(tsne$Y)
colnames(df_umap) <- c('UMAP1', 'UMAP2')
colnames(df_tsne) <- c('tSNE1', 'tSNE2')
ggplot(df_tsne, aes(tSNE1, tSNE2)) +
geom_point() +
theme_classic()
df_umap <- as.data.frame(df, umap$layout)
df
df_umap <- as.data.frame(df, umap$layout)
df_umap <- as.data.frame(df[,8:29], umap$layout)
install.packages(FactoMineR)
install.packages('FactoMineR')
library("FactoMineR")
df
mca <- MCA(dfdf[,8:29], graph = F)
mca <- MCA(df[,8:29], graph = F)
dfdf[,8:29] <- as.character(dfdf[,8:29])
df[,8:29] <- as.character(df[,8:29])
mca <- MCA(df[,8:29], graph = F)
ggplot(mca$eig) +
geom_bar()
mca$eig
library('factoextra')
install.packages('factoextra')
library('factoextra')
get_eigenvalue(mca)
ggplot(mca$eig$variance.percent) +
geom_bar()
ggplot(as.data.frame(mca$eig$variance.percent)) +
geom_bar()
as.data.frame(mca$eig)$variance.percent
as.data.frame(mca$eig)
eig <- as.data.frame(mca$eig)
ggplot(eig, aes(y = variance.percent)) +
geom_bar()
head(eig)
ggplot(eig, aes(y = `percentage of variance`)) +
geom_bar()
ggplot(eig, aes(x = `percentage of variance`)) +
geom_bar()
ggplot(eig, aes(y = `percentage of variance`)) +
geom_line()
head(eig)
ggplot(eig, aes(x = rownames(eig), y = `percentage of variance`)) +
geom_line()
ggplot(eig, aes(x = rownames(eig), y = `percentage of variance`)) +
geom_point()
fviz_screeplot(get_eigenvalue(mca), addlabels = TRUE, ylim = c(0, 45))
mca <- MCA(df[,8:29], graph = F)
fviz_screeplot(get_eigenvalue(mca), addlabels = TRUE, ylim = c(0, 45))
fviz_screeplot(mca, addlabels = TRUE, ylim = c(0, 45))
fviz_screeplot(mca, addlabels = TRUE, xlim = c(0, 45))
fviz_mca_biplot(mca,
repel = TRUE, # Avoid text overlapping (slow if many point)
ggtheme = theme_minimal())
fviz_mca_biplot(mca,
ggtheme = theme_minimal())
mca_vars_df = data.frame(mca$var$coord, Variable = rep(names(df[,8:29]), df[,8:29]))
mca_vars_df = data.frame(mca$var$coord)
mca_vars_df
head(mca_vars_df)
mca_vars_df = as.data.frame(mca$var$coord)
head(mca_vars_df)
mca$var
